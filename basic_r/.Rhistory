mpg %>%
filter(class == "suv") %>%
mutate(avg = (cty + hwy) / 2) %>%
group_by(manufacturer) %>%  #회사별
summarise(mean_avg = mean(avg)) %>%
arrange(desc(mean_avg)) %>%
head(10)
q1 <- mpg %>%
filter(class == "suv") %>%
mutate(avg = (cty + hwy) / 2) %>%
group_by(manufacturer) %>%  #회사별
summarise(mean_avg = mean(avg)) %>%
arrange(desc(mean_avg)) %>%
head(10)
q1
as.data.frame(q1)
# Q02
# mpg데이터의 class는 자동차 특징에 따라 분류된 변수입니다.
# class별 cty평균을 구하고 높은 순으로 정렬해 출력하세요.
mpg %>%
group_by(class) %>% #class로 그룹핑
summarise(cty_avg = mean(cty)) %>%  # 그룹핑된 것의 cty의 평균을 구해 추가
arrange(desc(cty_avg)) # 평균값으로 정렬
# Q02
# mpg데이터의 class는 자동차 특징에 따라 분류된 변수입니다.
# class별 cty평균을 구하고 높은 순으로 정렬해 출력하세요.
q2 <- mpg %>%
group_by(class) %>% #class로 그룹핑
summarise(cty_avg = mean(cty)) %>%  # 그룹핑된 것의 cty의 평균을 구해 추가
arrange(desc(cty_avg)) # 평균값으로 정렬
q2
class(q2)
as.data.frame(q2)
#제조사별 hwy평균, 상위 3개
mpg %>%
group_by(manufacturer) %>%
summarise(hwy_avg = mean(hwy)) %>%
arrange(desc(hwy_avg)) %>%
head(3)
mpg %>%
filter(class %in% "compact") %>%
group_by(manufacturer) %>%
summarise(count = n()) %>%
arrange(desc(count))
head(midwest, 0)
# Q2
# popadults 는 해당 지역의 성인 인구, poptotal 은 전체 인구를 나타냅니다. midwest 데이터에
# 전체 인구 대비 성년 인구 백분율(adult_of_percent)
# 전체 인구 대비 미성년 인구 백분율(young_of_percent) 변수를 추가하세요.
# 전체 인구 대비 성년 인구 백분율공식 = (성인인구/전체인구) * 100
midwest %>%
mutate(adult_of_percent = (poptotal / popadults) * 100)
# Q2
# popadults 는 해당 지역의 성인 인구, poptotal 은 전체 인구를 나타냅니다. midwest 데이터에
# 전체 인구 대비 성년 인구 백분율(adult_of_percent)
# 전체 인구 대비 미성년 인구 백분율(young_of_percent) 변수를 추가하세요.
# 전체 인구 대비 성년 인구 백분율공식 = (성인인구/전체인구) * 100
midwest %>%
mutate(adult_of_percent = (popadults / poptotal) * 100)
str(midwest)
young_of_percent = ((popadults - poptotal) / poptotal) * 100
# Q2
# popadults 는 해당 지역의 성인 인구, poptotal 은 전체 인구를 나타냅니다. midwest 데이터에
# 전체 인구 대비 성년 인구 백분율(adult_of_percent)
# 전체 인구 대비 미성년 인구 백분율(young_of_percent) 변수를 추가하세요.
# 전체 인구 대비 성년 인구 백분율공식 = (성인인구/전체인구) * 100
midwest %>%
mutate(adult_of_percent = (popadults / poptotal) * 100,
young_of_percent = ((popadults - poptotal) / poptotal) * 100)
# Q2
# popadults 는 해당 지역의 성인 인구, poptotal 은 전체 인구를 나타냅니다. midwest 데이터에
# 전체 인구 대비 성년 인구 백분율(adult_of_percent)
# 전체 인구 대비 미성년 인구 백분율(young_of_percent) 변수를 추가하세요.
# 전체 인구 대비 성년 인구 백분율공식 = (성인인구/전체인구) * 100
midwest %>%
mutate(adult_of_percent = (popadults / poptotal) * 100,
young_of_percent = ((poptotal - popadults) / poptotal) * 100)
# Q2
# popadults 는 해당 지역의 성인 인구, poptotal 은 전체 인구를 나타냅니다. midwest 데이터에
# 전체 인구 대비 성년 인구 백분율(adult_of_percent)
# 전체 인구 대비 미성년 인구 백분율(young_of_percent) 변수를 추가하세요.
# 전체 인구 대비 성년 인구 백분율공식 = (성인인구/전체인구) * 100
midwest %>%
mutate(adult_of_percent = (popadults / poptotal) * 100,
young_of_percent = 100-  adult_of_percent)
# Q2
# popadults 는 해당 지역의 성인 인구, poptotal 은 전체 인구를 나타냅니다. midwest 데이터에
# 전체 인구 대비 성년 인구 백분율(adult_of_percent)
# 전체 인구 대비 미성년 인구 백분율(young_of_percent) 변수를 추가하세요.
# 전체 인구 대비 성년 인구 백분율공식 = (성인인구/전체인구) * 100
midwest2 <- midwest %>%
mutate(adult_of_percent = (popadults / poptotal) * 100,
young_of_percent = 100-  adult_of_percent)
# Q3
# 아래 등급표에 따라 grade변수를 추가하고, 미성년인구 백분율이 가장 높은 상위 5개
# county(지역), 미성년백분율, grade를 출력하세요.(large, mid, row로 해라)
midwest2 %>%
mutate(grage = ifelse(young_of_percent >= 40, "large",
ifelse(young_of_percent >= 35, "mid", "row")),
)
# Q4
# popasian은 해당 지역의 아시아인 인구를 나타냅니다. '전체 인구 대비 아시아인 인구 백분율' 변수를 추가하고,하위 10개 지역의 state(주), county(지역명), 아시아인 인구 백분율을 출력하세요.
midwest2 %>%
mutate(asian_percent = (popasian / poptotal) * 100)
str(midwest)
# Q4
# popasian은 해당 지역의 아시아인 인구를 나타냅니다. '전체 인구 대비 아시아인 인구 백분율' 변수를 추가하고,하위 10개 지역의 state(주), county(지역명), 아시아인 인구 백분율을 출력하세요.
midwest2 %>%
mutate(asian_percent = (popasian / poptotal) * 100)
# Q4
# popasian은 해당 지역의 아시아인 인구를 나타냅니다. '전체 인구 대비 아시아인 인구 백분율' 변수를 추가하고,하위 10개 지역의 state(주), county(지역명), 아시아인 인구 백분율을 출력하세요.
midwest2 %>%
mutate(asian_percent = (popasian / poptotal) * 100) %>%
arrange(asian_percent)
# Q4
# popasian은 해당 지역의 아시아인 인구를 나타냅니다. '전체 인구 대비 아시아인 인구 백분율' 변수를 추가하고,하위 10개 지역의 state(주), county(지역명), 아시아인 인구 백분율을 출력하세요.
midwest2 %>%
mutate(asian_percent = (popasian / poptotal) * 100) %>%
arrange(asian_percent) %>%
head(10)
# Q4
# popasian은 해당 지역의 아시아인 인구를 나타냅니다. '전체 인구 대비 아시아인 인구 백분율' 변수를 추가하고,하위 10개 지역의 state(주), county(지역명), 아시아인 인구 백분율을 출력하세요.
midwest2 %>%
mutate(asian_percent = (popasian / poptotal) * 100) %>%
arrange(asian_percent) %>%
head(10) %>%
select(state, county, asian_percent)
# Q2
# popadults 는 해당 지역의 성인 인구, poptotal 은 전체 인구를 나타냅니다. midwest 데이터에
# 전체 인구 대비 성년 인구 백분율(adult_of_percent)
# 전체 인구 대비 미성년 인구 백분율(young_of_percent) 변수를 추가하세요.
# 전체 인구 대비 성년 인구 백분율공식 = (성인인구/전체인구) * 100
midwest2 <- midwest %>%
mutate(adult_of_percent = (popadults / poptotal) * 100,2 ,
young_of_percent = 100 - adult_of_percent)
# Q2
# popadults 는 해당 지역의 성인 인구, poptotal 은 전체 인구를 나타냅니다. midwest 데이터에
# 전체 인구 대비 성년 인구 백분율(adult_of_percent)
# 전체 인구 대비 미성년 인구 백분율(young_of_percent) 변수를 추가하세요.
# 전체 인구 대비 성년 인구 백분율공식 = (성인인구/전체인구) * 100
midwest2 <- midwest %>%
mutate(adult_of_percent = (popadults / poptotal) * 100,2 ,
young_of_percent = 100 - adult_of_percent)
midwest2
# Q2
# popadults 는 해당 지역의 성인 인구, poptotal 은 전체 인구를 나타냅니다. midwest 데이터에
# 전체 인구 대비 성년 인구 백분율(adult_of_percent)
# 전체 인구 대비 미성년 인구 백분율(young_of_percent) 변수를 추가하세요.
# 전체 인구 대비 성년 인구 백분율공식 = (성인인구/전체인구) * 100
midwest2 <- midwest %>%
mutate(adult_of_percent = (popadults / poptotal) * 100, 2) %>%
mutate(young_of_percent = 100 - adult_of_percent, 2)
midwest2
mutate(adult_of_percent = round((popadults / poptotal * 100), 2) %>%
# Q2
# popadults 는 해당 지역의 성인 인구, poptotal 은 전체 인구를 나타냅니다. midwest 데이터에
# 전체 인구 대비 성년 인구 백분율(adult_of_percent)
# 전체 인구 대비 미성년 인구 백분율(young_of_percent) 변수를 추가하세요.
# 전체 인구 대비 성년 인구 백분율공식 = (성인인구/전체인구) * 100
midwest2 <- midwest %>%
mutate(adult_of_percent = round((popadults / poptotal) * 100, 2)) %>%
mutate(young_of_percent = 100 - adult_of_percent, 2)
midwest2
midwest2
View(midwest2)
View(midwest2)
# Q2
# popadults 는 해당 지역의 성인 인구, poptotal 은 전체 인구를 나타냅니다. midwest 데이터에
# 전체 인구 대비 성년 인구 백분율(adult_of_percent)
# 전체 인구 대비 미성년 인구 백분율(young_of_percent) 변수를 추가하세요.
# 전체 인구 대비 성년 인구 백분율공식 = (성인인구/전체인구) * 100
midwest2 <- midwest %>%
mutate(adult_of_percent = round((popadults / poptotal) * 100, 2)) %>%
mutate(young_of_percent = 100 - adult_of_percent)
midwest2
# Q5
# popasian은 해당 지역의 아시아인 인구를 나타냅니다. '전체 인구 대비 아시아인 인구 백분율' 변수를 추가하고,하위 10개 지역의 state(주), county(지역명), 아시아인 인구 백분율을 출력하세요.
midwest2 %>%
mutate(asian_percent = (popasian / poptotal) * 100) %>%
arrange(asian_percent) %>%
head(10) %>%
select(state, county, asian_percent)
# Q5
# popasian은 해당 지역의 아시아인 인구를 나타냅니다. '전체 인구 대비 미성년 인구 백분율' 변수를 추가하고,하위 10개 지역의 state(주), county(지역명), 미성년 인구 백분율을 출력하세요.
midwest2 %>%
select(state, county, young_of_percent)
# Q5
# popasian은 해당 지역의 아시아인 인구를 나타냅니다. '전체 인구 대비 미성년 인구 백분율' 변수를 추가하고,하위 10개 지역의 state(주), county(지역명), 미성년 인구 백분율을 출력하세요.
midwest2 %>%
select(state, county, young_of_percent) %>%
arrange(young_of_percent)
# Q5
# popasian은 해당 지역의 아시아인 인구를 나타냅니다. '전체 인구 대비 미성년 인구 백분율' 변수를 추가하고,하위 10개 지역의 state(주), county(지역명), 미성년 인구 백분율을 출력하세요.
midwest2 %>%
select(state, county, young_of_percent) %>%
arrange(young_of_percent) %>%
head(10)
# Q5
# popasian은 해당 지역의 아시아인 인구를 나타냅니다. '전체 인구 대비 미성년 인구 백분율' 변수를 추가하고,하위 10개 지역의 state(주), county(지역명), 미성년 인구 백분율을 출력하세요.
midwest2 %>%
select(state, county, young_of_percent) %>%
arrange(desc(young_of_percent)) %>%
head(10)
# Q5
# popasian은 해당 지역의 아시아인 인구를 나타냅니다. '전체 인구 대비 아시아인 인구 백분율' 변수를 추가하고,하위 10개 지역의 state(주), county(지역명), 아시아인 인구 백분율을 출력하세요.
midwest2 %>%
mutate(asian_percent = (popasian / poptotal) * 100) %>%
arrange(asian_percent) %>%
select(state, county, asian_percent) %>%
head(10)
# stringr은 벡터형의 문자열을 다루는 다양한 기능이 들어있다
install.packages("stringr")
library(stringr)
read.csv("data/emp.csv")
emp <- read.csv("data/emp.csv")
emp
emp
emp <- read.csv("data/emp.csv")
emp
str(emp)
class(emp)
# str_detect(벡터형, 정규식)
?str_detect
emp$first_name
emp$first_name
emp$FIRST_NAME
str_detect(emp$FIRST_NAME, "a")
str_detect(emp$FIRST_NAME, "[aA]")
str_detect(emp$FIRST_NAME, "^a")
str_detect(emp$FIRST_NAME, "^[aA]")
str_detect(emp$FIRST_NAME, "a$")
str_detect(emp$FIRST_NAME, "[aA]$")
# str_count(백터형, 정규식): 출현빈도
str_count(emp$JOB_ID, "A") # A의 출현빈도도
str_count(emp$JOB_ID, "PROG")
str_count(emp$JOB_ID, toupper("prog"))
# str_length(백터)
nchar(emp$FIRST_NAME)
# str_length(백터)
length(emp$FIRST_NAME)
str_length(emp$FIRST_NAME)
# $ str_c(백터, 벡터, 옵션): paste()와 동일
paste(emp$FIRST_NAME, emp$LAST_NAME)
paste(emp$FIRST_NAME, emp$LAST_NAME, sep = "-")
str_c(emp$FIRST_NAME, emp$LAST_NAME, sep = "")
paste(emp$FIRST_NAME, collapse = ",")
str_c(emp$FIRST_NAME, collapse = ",")
# str_sub(벡터, 시작, 끝): substr()과 동일함
substr(emp$HIRE_DATE, 1, 2)
str_sub(emp$HIRE_DATE, 1, 2)
substr(emp$HIRE_DATE, 4, nchar(emp$HIRE_DATE))
str_sub(emp$HIRE_DATE, 4)
#★★
# str_replace(벡터, 패턴, 치환문자): 처음매칭되는 값을 변경
emp$PHONE_NUMBER
str_replace(emp$phone_number, ".", ())
str_replace(emp$phone_number, ".", "()"
str_replace(emp$phone_number, ".", "()")
str_replace(emp$phone_number, ".", "")
str_replace(emp$PHONE_NUMBER, ".", "")
str_replace(emp$PHONE_NUMBER, ".", "")
str_replace(emp$PHONE_NUMBER, ".", ")")
#.은 정규표현식에서 모든문자를 표현
str_replace(emp$PHONE_NUMBER, "\\.", ")")
# str_replace_all(벡터, 패턴, 치환문자): 매칭되는 모든 값을 변경
str_replace_all(emp$PHONE_NUMBER, "\\.", "-")
str_replace_all(emp$PHONE_NUMBER, "\\.", "")
# 치환ㄱ결과를 저장
emp$PHONE_NUMBER <- str_replace_all(emp$PHONE_NUMBER, "\\.", "-")
emp$PHONE_NUMBER
# ===================================================================
# 문제
# HIRE_DATE의 타입을 확인하고 2020-01-06형식의 날짜형 데이터로 전부 변경
emp$HIRE_DATE
# ===================================================================
# 문제
# HIRE_DATE의 타입을 확인하고 2020-01-06형식의 날짜형 데이터로 전부 변경
class(emp$HIRE_DATE)
str_replace_all(emp$HIRE_DATE, "/", "-")
substr(HIRE_DATE, 1, 2)
substr(emp$HIRE_DATE, 1, 2)
emp %>%
str_replace(substr(HIRE_DATE, 1, 2), "20substr(HIRE_DATE, 1, 2)")
emp %>%
str_replace(substr(HIRE_DATE, 1, 2), "20"+substr(HIRE_DATE, 1, 2))
emp %>%
str_replace(substr(HIRE_DATE, 1, 2), "20"+substr(HIRE_DATE, 1, 2))
emp %>%
str_replace(str_sub(HIRE_DATE, 1, 2), "20" + substr(HIRE_DATE, 1, 2))
emp %>%
str_replace(str_sub(emp$HIRE_DATE, 1, 2), "20" + str_sub(HIRE_DATE, 1, 2))
emp %>%
str_replace(str_sub(HIRE_DATE, 1, 2), "20" + str_sub(HIRE_DATE, 1, 2))
emp %>%
str_sub(HIRE_DATE, 1,2)
emp %>%
str_sub(HIRE_DATE, 1, 2)
str_sub(emp$HIRE_DATE, 1, 2)
emp %>%
str_sub(HIRE_DATE, 1, 2)
emp %>%
str_sub(HIRE_DATE, 1, 2)
# ===================================================================
# 문제
# HIRE_DATE의 타입을 확인하고 2020-01-06형식의 날짜형 데이터로 전부 변경
class(emp$HIRE_DATE)
# ===================================================================
# 문제
# HIRE_DATE의 타입을 확인하고 2020-01-06형식의 날짜형 데이터로 전부 변경
emp$HIRE_DATE
emp %>%
str_sub(HIRE_DATE, 1, 2)
str_sub(emp$HIRE_DATE, 1, 2)
x1 <- str_sub(emp$HIRE_DATE, 1, 2)
str_replace(emp$HIRE_DATE, x1, 20+x1)
str_replace(emp$HIRE_DATE, x1, 20x1)
str_replace(emp$HIRE_DATE, x1, "20")
str_replace(emp$HIRE_DATE, x1, "20x1")
str_replace(emp$HIRE_DATE, x1, "20"+x1)
str_c(emp$FIRST_NAME, emp$LAST_NAME, sep = "-")
str_replace_all(emp$HIRE_DATE, "/", "-")
str_c(20, str_replace_all(emp$HIRE_DATE, "/", "-"))
emp$HIRE_DATE <-  as.Date(str_c(20, str_replace_all(emp$HIRE_DATE, "/", "-")))
emp$HIRE_DATE
data <- data.frame(id = c(1:5),
gender = c("M", "F", NA, "M", "M"),
score = c(10, 20, 30, 40, NA))
data
# 결측치가 포함되어 있다면 ,결과가 NA로 표기 된다
mean(data$score)
# 결측치가 포함되어 있다면 ,결과가 NA로 표기 된다
mean(data$score)
data
data <- data.frame(id = c(1:5),
gender = c("M", "F", NA, "M", "M"),
score = c(10, 20, 30, 40, NA))
data
# 결측치가 포함되어 있다면 ,결과가 NA로 표기 된다
mean(data$score)
# 결측치를 확인하는 함수 is.na()
is.na(data)
is.na(data$score)
is.na(data$gender)
# 데이터가 많아지면 결측치의 빈도를 확인해서 결측 여부를 판별
table(is.na(data$gender))
table(is.na(data$score))
# 결측치 제거
data %>%
filter(!is.na(score))
# 여러 결측치 제거
data %>%
filter(!is.na(score) & !is.na(gender))
# na.omit(data): 모든 열에서 결측치가 하나라도 존재한다면 제거
# 단, 분석데이터와 상관없는 열이 NA값을 가졌을 때, 데이터 손실이 발생될 수 있으므로 사용시 주의
# (거의 안쓴다_리스크가 너무 큼)
na.omit(data)
# 함수에서 결측치 제외
mean(data$score, na.rm = T)
sum(data$score, na.rm = T)
# summarise 요약함수에서 적용
exam <- read.csv("data/excel_exam.csv")
exam
# 인덱싱으로 결측치 삽입 exam[행, 열]
exam[c(1,3,5,8,11), "math"] <-NA
exam
median(data$score, na.rm = T)
table(is.na(exam$math))
exam %>%
summarise(sum_math = sum(math, na.rm = T),
mean_math = mean(math, na.rm = T))
exam %>%
filter(!is.na(math) & !is.na(score))
exam %>%
filter(!is.na(math)) %>%
summarise(sum_math = sum(math),
mean_math = mean(math))
# 결측치를 처리하는 방법
# 2. 결측치에 값을 대입(ex - 평균, 최빈값)
table(is.na(exam))
# step1 - 결측값이 제거된 math데이터의 평균을 구합니다
# step - 평균값을 ifelse() 구문으로 치환합니다
mean(exam$math, na.rm = T)
ifelse(is.na(exam$math), mean(exam$math, na.rm = T, exam$math))
ifelse(is.na(exam$math), mean(exam$math, na.rm = T, exam$math))
ifelse(is.na(exam$math), mean(exam$math, na.rm = T), exam$math)
exam$math <- ifelse(is.na(exam$math), mean(exam$math, na.rm = T), exam$math)
table(is.na(exam))
mpg <- as.data.frame(mpg)
mpg[c(65, 124, 131, 153, 212), "hwy"] <- NA
# Q1
# drv(구동방식) 별 hwy(고속도로연비) 평균이 어떻게 다른지 확인하려고 합니다.
# 결측치를 확인하고 drv, hwy 변수에 결측치가 몇 개 있는지 확인하세요.
table(mpg$hwy)
is.na(mpg$hwy)
# Q1
# drv(구동방식) 별 hwy(고속도로연비) 평균이 어떻게 다른지 확인하려고 합니다.
# 결측치를 확인하고 drv, hwy 변수에 결측치가 몇 개 있는지 확인하세요.
mpg$hwy
mpg %>%
mutate(hwy_avg = ifelse(is.na(mpg$hwy), mean(mpg$hwy, na.rm = T), mpg$hwy))
mpg %>%
mutate(hwy_avg = ifelse(is.na(mpg$hwy), mean(mpg$hwy, na.rm = T), mpg$hwy)) %>%
select(hwy)
mpg %>%
mutate(hwy_avg = ifelse(is.na(mpg$hwy), mean(mpg$hwy, na.rm = T), mpg$hwy)) %>%
select(hwy)
# Q1
# drv(구동방식) 별 hwy(고속도로연비) 평균이 어떻게 다른지 확인하려고 합니다.
# 결측치를 확인하고 drv, hwy 변수에 결측치가 몇 개 있는지 확인하세요.
table(is.na(mpg(drv)))
# Q1
# drv(구동방식) 별 hwy(고속도로연비) 평균이 어떻게 다른지 확인하려고 합니다.
# 결측치를 확인하고 drv, hwy 변수에 결측치가 몇 개 있는지 확인하세요.
table(is.na(mpg(drv)))
# Q1
# drv(구동방식) 별 hwy(고속도로연비) 평균이 어떻게 다른지 확인하려고 합니다.
# 결측치를 확인하고 drv, hwy 변수에 결측치가 몇 개 있는지 확인하세요.
table(is.na(mpg$drv))
table(is.na(mpg$hwy))
# Q2
# filter() 를 이용해서 결측치를 제거하고 어떤 구동 방식 평균이 높은지 그룹별로 확인하고 차순정렬하세요
mpg %>%
group_by(drv) %>%
filter(!is.na(hwy)) %>%
summarise(hwy_mean = mean(hwy))
# Q2
# filter() 를 이용해서 결측치를 제거하고 어떤 구동 방식 평균이 높은지 그룹별로 확인하고 차순정렬하세요
mpg %>%
group_by(drv) %>%
filter(!is.na(hwy)) %>%  # 결측치 제거하고
summarise(hwy_mean = mean(hwy)) %>%
arrange(desc(hwy_mean))
d1 <- data.frame(gender = c(1,2,1,1,3),
score = c(12, 43, 65, 54, 23))
d1
table(d1$gender)
# 이상치를 NA값으로 변경
d1$gender <- ifelse(d1$gender === 3, NA, d1$gender)
# 이상치를 NA값으로 변경
d1$gender <- ifelse(d1$gender == 3, NA, d1$gender)
d1
# NA를 filter로 제외하고 사용
d1 %>%
filter(!is.na(gender)) %>%
summarise(mean(gender))
# NA를 filter로 제외하고 사용
d1 %>%
filter(!is.na(gender)) %>%
group_by(gender) %>%
summarise(gender_mean = mean(score))
# 극단값인 경우 제거할 것
# boxplot(컬럼)
boxplot(mpg$hwy)
boxplot(mpg$hwy)$stats
# 극단치 경계가 12, 37초과, 미만인 데이터는 NA처리리
ifelse(mpg$hwy > 37, NA, mpg$hwy)
# 극단치 경계가 12, 37초과, 미만인 데이터는 NA처리리
mpg$hwy <-  ifelse(mpg$hwy > 37, NA, mpg$hwy)
# 극단치 경계가 12미만, 37초과 데이터는 NA처리
mpg$hwy <-  ifelse(mpg$hwy > 37 | mpg$hwy < 12, NA, mpg$hwy)
table(is.na(mpg$hwy))
mpg <- as.data.frame(mpg)
table(mpg$hwy)
table(is.na(mpg$hwy))
table(is.na(mpg$hwy))
table(mpg$hwy)
rm(mpg)
mpg <- as.data.frame(mpg)
table(mpg$hwy)
table(is.na(mpg$hwy))
# 극단치 경계가 12미만, 37초과 데이터는 NA처리
mpg$hwy <-  ifelse(mpg$hwy > 37 | mpg$hwy < 12, NA, mpg$hwy)
table(is.na(mpg$hwy))
boxplot(mpg$hwy)$stats # 극단치가 12, 37인 것을 확인
rm(mpg)
mpg <- as.data.frame(mpg)
boxplot(mpg$hwy)$stats # 극단치가 12, 37인 것을 확인
# 극단치 경계가 12미만, 37초과 데이터는 NA처리
mpg$hwy <-  ifelse(mpg$hwy > 37 | mpg$hwy < 12, NA, mpg$hwy)
table(is.na(mpg$hwy))
# NA처리한 것은 제거하고 분석
mpg %>%
filter(!is.na(hwy)) %>%
group_by(drv) %>%
summarise(mean_der = mean(hwy))
# NA처리한 것은 제거하고 분석
mpg %>%
filter(!is.na(hwy)) %>%
group_by(drv) %>%
summarise(mean_der = mean(hwy)) %>%
arrange(mean_der)
# NA처리한 것은 제거하고 분석
mpg %>%
filter(!is.na(hwy)) %>%
group_by(drv) %>%
summarise(mean_der = mean(hwy)) %>%
arrange(desc(mean_der))
# 숙제 옆에 문제풀기네
mpg <- as.data.frame(mpg)
mpg
class(mpg)
mpg[c(10, 14, 58, 93), "drv"] <- "k"
mpg[c(29, 43, 129, 203), "cty"] <- c(3,4,39,42)
is.na(mpg)
table(is.na(mpg))
boxplot(mpg)
boxplot(mpg$drv)
boxplot(mpg$drv)
boxplot(mpg$drv)
boxplot(mpg$drv)
boxplot(mpg$cty)
mpg$drv
